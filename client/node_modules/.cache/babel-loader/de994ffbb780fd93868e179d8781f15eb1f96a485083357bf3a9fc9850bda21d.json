{"ast":null,"code":"export const createImage = url => new Promise((resolve, reject) => {\n  const image = new Image();\n  image.addEventListener(\"load\", () => resolve(image));\n  image.addEventListener(\"error\", error => reject(error));\n  image.setAttribute(\"crossOrigin\", \"anonymous\"); // needed to avoid cross-origin issues on CodeSandbox\n  image.src = url;\n});\nexport function getRadianAngle(degreeValue) {\n  return degreeValue * Math.PI / 180;\n}\n\n/**\r\n * Returns the new bounding area of a rotated rectangle.\r\n */\nexport function rotateSize(width, height, rotation) {\n  const rotRad = getRadianAngle(rotation);\n  return {\n    width: Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),\n    height: Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height)\n  };\n}\n\n/**\r\n * This function was adapted from the one in the ReadMe of https://github.com/DominicTobias/react-image-crop\r\n */\nexport default async function getCroppedImg(imageSrc, pixelCrop) {\n  let rotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let flip = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n    horizontal: false,\n    vertical: false\n  };\n  const image = await createImage(imageSrc);\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    return null;\n  }\n  const rotRad = getRadianAngle(rotation);\n\n  // calculate bounding box of the rotated image\n  //   const { width: bBoxWidth, height: bBoxHeight } = rotateSize(\n  //     image.width,\n  //     image.height,\n  //     rotation\n  //   );\n\n  // set canvas size to match the bounding box\n  canvas.width = bBoxWidth;\n  canvas.height = bBoxHeight;\n\n  // translate canvas context to a central location to allow rotating and flipping around the center\n  ctx.translate(bBoxWidth / 2, bBoxHeight / 2);\n  ctx.rotate(rotRad);\n  ctx.scale(flip.horizontal ? -1 : 1, flip.vertical ? -1 : 1);\n  ctx.translate(-image.width / 2, -image.height / 2);\n\n  // draw rotated image\n  ctx.drawImage(image, 0, 0);\n  const croppedCanvas = document.createElement(\"canvas\");\n  const croppedCtx = croppedCanvas.getContext(\"2d\");\n  if (!croppedCtx) {\n    return null;\n  }\n\n  // Set the size of the cropped canvas\n  croppedCanvas.width = pixelCrop.width;\n  croppedCanvas.height = pixelCrop.height;\n\n  // Draw the cropped image onto the new canvas\n  croppedCtx.drawImage(canvas, pixelCrop.x, pixelCrop.y, pixelCrop.width, pixelCrop.height, 0, 0, pixelCrop.width, pixelCrop.height);\n\n  // As Base64 string\n  // return croppedCanvas.toDataURL('image/jpeg');\n\n  // As a blob\n  return new Promise((resolve, reject) => {\n    croppedCanvas.toBlob(file => {\n      resolve(URL.createObjectURL(file));\n    }, \"image/jpeg\");\n  });\n}","map":{"version":3,"names":["createImage","url","Promise","resolve","reject","image","Image","addEventListener","error","setAttribute","src","getRadianAngle","degreeValue","Math","PI","rotateSize","width","height","rotation","rotRad","abs","cos","sin","getCroppedImg","imageSrc","pixelCrop","arguments","length","undefined","flip","horizontal","vertical","canvas","document","createElement","ctx","getContext","bBoxWidth","bBoxHeight","translate","rotate","scale","drawImage","croppedCanvas","croppedCtx","x","y","toBlob","file","URL","createObjectURL"],"sources":["D:/program project/React Django/imageupload/client/src/Components/CropImage.js"],"sourcesContent":["export const createImage = (url) =>\r\n  new Promise((resolve, reject) => {\r\n    const image = new Image();\r\n    image.addEventListener(\"load\", () => resolve(image));\r\n    image.addEventListener(\"error\", (error) => reject(error));\r\n    image.setAttribute(\"crossOrigin\", \"anonymous\"); // needed to avoid cross-origin issues on CodeSandbox\r\n    image.src = url;\r\n  });\r\n\r\nexport function getRadianAngle(degreeValue) {\r\n  return (degreeValue * Math.PI) / 180;\r\n}\r\n\r\n/**\r\n * Returns the new bounding area of a rotated rectangle.\r\n */\r\nexport function rotateSize(width, height, rotation) {\r\n  const rotRad = getRadianAngle(rotation);\r\n\r\n  return {\r\n    width:\r\n      Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),\r\n    height:\r\n      Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height),\r\n  };\r\n}\r\n\r\n/**\r\n * This function was adapted from the one in the ReadMe of https://github.com/DominicTobias/react-image-crop\r\n */\r\nexport default async function getCroppedImg(\r\n  imageSrc,\r\n  pixelCrop,\r\n  rotation = 0,\r\n  flip = { horizontal: false, vertical: false }\r\n) {\r\n  const image = await createImage(imageSrc);\r\n  const canvas = document.createElement(\"canvas\");\r\n  const ctx = canvas.getContext(\"2d\");\r\n\r\n  if (!ctx) {\r\n    return null;\r\n  }\r\n\r\n  const rotRad = getRadianAngle(rotation);\r\n\r\n  // calculate bounding box of the rotated image\r\n  //   const { width: bBoxWidth, height: bBoxHeight } = rotateSize(\r\n  //     image.width,\r\n  //     image.height,\r\n  //     rotation\r\n  //   );\r\n\r\n  // set canvas size to match the bounding box\r\n  canvas.width = bBoxWidth;\r\n  canvas.height = bBoxHeight;\r\n\r\n  // translate canvas context to a central location to allow rotating and flipping around the center\r\n  ctx.translate(bBoxWidth / 2, bBoxHeight / 2);\r\n  ctx.rotate(rotRad);\r\n  ctx.scale(flip.horizontal ? -1 : 1, flip.vertical ? -1 : 1);\r\n  ctx.translate(-image.width / 2, -image.height / 2);\r\n\r\n  // draw rotated image\r\n  ctx.drawImage(image, 0, 0);\r\n\r\n  const croppedCanvas = document.createElement(\"canvas\");\r\n\r\n  const croppedCtx = croppedCanvas.getContext(\"2d\");\r\n\r\n  if (!croppedCtx) {\r\n    return null;\r\n  }\r\n\r\n  // Set the size of the cropped canvas\r\n  croppedCanvas.width = pixelCrop.width;\r\n  croppedCanvas.height = pixelCrop.height;\r\n\r\n  // Draw the cropped image onto the new canvas\r\n  croppedCtx.drawImage(\r\n    canvas,\r\n    pixelCrop.x,\r\n    pixelCrop.y,\r\n    pixelCrop.width,\r\n    pixelCrop.height,\r\n    0,\r\n    0,\r\n    pixelCrop.width,\r\n    pixelCrop.height\r\n  );\r\n\r\n  // As Base64 string\r\n  // return croppedCanvas.toDataURL('image/jpeg');\r\n\r\n  // As a blob\r\n  return new Promise((resolve, reject) => {\r\n    croppedCanvas.toBlob((file) => {\r\n      resolve(URL.createObjectURL(file));\r\n    }, \"image/jpeg\");\r\n  });\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}